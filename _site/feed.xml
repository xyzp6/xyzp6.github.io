<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-16T23:50:04+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">xyzp</title><subtitle>Artificial Intelligence trends and concepts made easy.</subtitle><author><name>xyzp</name></author><entry><title type="html">本地视频</title><link href="http://localhost:4000/%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91.html" rel="alternate" type="text/html" title="本地视频" /><published>2023-10-05T03:32:20+08:00</published><updated>2023-10-05T03:32:20+08:00</updated><id>http://localhost:4000/%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91</id><content type="html" xml:base="http://localhost:4000/%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91.html"><![CDATA[<p>这是一个基于谷歌<a href="https://developer.android.google.cn/guide/topics/media/media3">Media3</a>开发的本地视频播放软件，使用<a href="https://m3.material.io/">Material Design 3</a>设计规范，意在实现轻量，美观，实用。</p>

<h2 id="图片">图片</h2>

<p><img src="https://github.com/xyzp6/movie/assets/87695187/010a0701-4bce-4977-8184-0539927480cb" alt="首页" />
<img src="https://github.com/xyzp6/movie/assets/87695187/99e7e8b9-1653-43b4-a845-67f96fb9ef1b" alt="历史记录" />
<img src="https://github.com/xyzp6/movie/assets/87695187/07ce2da0-b149-4af4-b9c7-731690c4cb4d" alt="设置" />
<img src="https://github.com/xyzp6/movie/assets/87695187/7439a9df-5db5-41f5-a683-a0412bf81000" alt="横屏" />
<img src="https://github.com/xyzp6/movie/assets/87695187/38c0c2f2-0fcb-49e0-93bb-fbf020527736" alt="播放页2" />
<img src="https://github.com/xyzp6/movie/assets/87695187/850d1fdc-8fb5-42be-9fea-d5ecc8469f27" alt="播放页1" /></p>

<h2 id="已实现功能">已实现功能</h2>

<ul>
  <li>选择视频内置音轨和字幕轨道</li>
  <li>手势调节（亮度，音量，进度）</li>
  <li>按文件夹分类视频</li>
  <li>检索本地视频</li>
  <li>保存视频进度</li>
  <li>批量管理视频</li>
  <li>主页背景设置</li>
  <li>温馨提醒</li>
  <li>……</li>
</ul>

<h2 id="已知问题">已知问题</h2>

<ul>
  <li>双语字幕无法正常显示（多字幕轨道可以）</li>
</ul>]]></content><author><name>xyzp</name></author><category term="coding" /><category term="Android" /><summary type="html"><![CDATA[一个基于谷歌Media3开发的开源本地视频播放软件，使用Material Design 3设计规范]]></summary></entry><entry><title type="html">Conway’s Game of Life</title><link href="http://localhost:4000/conways-game-of-life.html" rel="alternate" type="text/html" title="Conway’s Game of Life" /><published>2021-02-11T03:32:20+08:00</published><updated>2021-02-11T03:32:20+08:00</updated><id>http://localhost:4000/conways-game-of-life</id><content type="html" xml:base="http://localhost:4000/conways-game-of-life.html"><![CDATA[<p>I&nbsp;am lately trying to take on coding again. It had always been a part of my life since my early years when I&nbsp;learned to program a Tandy Color Computer at the age of 8, the good old days.</p>

<p><img src="./assets/img/posts/20210210/300px-TRS-80_Color_Computer_3.jpg" alt="Tandy Color Computer TRS80 III" /><small>Tandy Color Computer TRS80 III</small></p>

<p>Having already programed in Java, C# and of course BASIC, I&nbsp;thought it would be a great idea to learn Python since I&nbsp;have great interest in data science and machine learning, and those two topics seem to have an avid community within Python coders.</p>

<p>For one of my starter quick programming tasks, I&nbsp;decided to code Conway's Game of Life, a very simple cellular automata that basically plays itself.</p>

<p>The game consists of a grid of n size, and within each block of the grid a cell could either be dead or alive according to these rules:</p>

<ul><li>If a cell has less than 2 neighbors, meaning contiguous alive cells, the cell will die of loneliness</li><li>If a cell has more than 3 neighbors, it will die of overpopulation</li><li>If an empty block has exactly 3 contiguous alive neighbors, a new cell will be born in that spot</li><li>If an alive cell has 2 or 3 alive neighbors, it continues to live</li></ul>

<p><img src="./assets/img/posts/20210210/GameOfLife.gif" alt="Conway's rules for the Game of Life" /><small>Conway’s rules for the Game of Life</small></p>

<p>To make it more of a challenge I&nbsp;also decided to implement an <em>"sparse" </em>method of recording the game board, this means that instead of the typical 2d array representing the whole board, I&nbsp;will only record the cells which are alive. Saving a lot of memory space and processing time, while adding some spice to the challenge.</p>

<p>The trickiest part was figuring out how to calculate which empty blocks had exactly 3 alive neighbors so that a new cell will spring to life there, this is trivial in the case of recording the whole grid, because we just iterate all over the board and find the alive neighbors of ALL&nbsp;the blocks in the grid, but in the case of only keeping the alive cells proved quite a challenge.</p>

<p>In the end the algorithm ended up as follows:</p>

<ol><li>Iterate through all the alive cells and get all of their neighbors</li></ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_neighbors</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
    <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="nf">if </span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">size_y</span><span class="p">):</span>
                    <span class="n">neighbors</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">neighbors</span>
</code></pre></div></div>

<ol start="2"><li>Mark all the neighboring blocks as having +1 neighbor each time a particular cell is encountered. This way, for each neighboring alive cell the counter of the particular block will increase, and in the end it will contain the total number of live cells which are contiguous to it.</li></ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">next_state</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
    <span class="n">alive_neighbors</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">self</span><span class="p">.</span><span class="n">alive_cells</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alive_neighbors</span><span class="p">:</span>
            <span class="n">alive_neighbors</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">get_neighbors</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alive_neighbors</span><span class="p">:</span>
                <span class="n">alive_neighbors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">alive_neighbors</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>The trick was using a dictionary to keep the record of the blocks that have alive neighbors and the cells who are alive in the current state but have zero alive neighbors (thus will die).</p>

<p>With the dictionary it became easy just to add cells and increase their neighbor counter each time it was encountered as a neighbor of an alive cell.</p>

<p>Having the dictionary now filled with all the cells that have alive neighbors and how many they have, it was just a matter of applying the rules of the game:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">alive_neighbors</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">alive_neighbors</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">alive_neighbors</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">alive_cells</span><span class="p">.</span><span class="nf">discard</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">alive_neighbors</span><span class="p">[</span><span class="n">cell</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">self</span><span class="p">.</span><span class="n">alive_cells</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
</code></pre></div></div>

<p>Notice that since I am keeping an array of the coordinates of only the cells who are alive, I could apply just 3 rules, die of loneliness, die of overpopulation and become alive from reproduction (exactly 3 alive neighbors) because the ones who have 2 or 3 neighbors and are already alive, can remain alive in the next iteration.</p>

<p>I&nbsp;found it very interesting to implement the Game of Life like this, it was quite a refreshing challenge and I am beginning to feel my coding skills ramping up again.</p>]]></content><author><name>Armando Maynez</name></author><category term="coding" /><category term="python" /><summary type="html"><![CDATA[Taking on the challenge of picking up coding again through interesting small projects, this time it is the turn of Conway's Game of Life.]]></summary></entry></feed>